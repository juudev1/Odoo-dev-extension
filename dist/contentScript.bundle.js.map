{"version":3,"file":"contentScript.bundle.js","mappings":";;;;;AACA;AAAA;AAAA;AADA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAHA;AAIA;AAAA;AAiBA;AACA;AACA;AACA;AAHA;AAAA;AAjBA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAMA;AAAA;AAaA;AACA;AACA;AACA;AACA;AACA;AALA;AAAA;AAbA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAQA;AAAA;AA8BA;AACA;AACA;AACA;AAHA;AAAA;AA9BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAMA;AAAA;AAoBA;AAAA;AAAA;AApBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA","sources":["webpack://odoo_dev/./src/extension/contentScriptIsolated.js"],"sourcesContent":["// src/extension/contentScriptIsolated.js\r\n\r\n// --- Constants for Storage Keys ---\r\nconst EXTENSION_ENABLED_KEY = 'odooDevExtensionEnabled';\r\nconst BACKGROUND_ENABLED_KEY = 'odooDevEnableBackground';\r\nconst IMAGE_STORAGE_KEY = 'odoo_bg'; // Assuming this is your key for the image data URL\r\n\r\n// --- Module-level State ---\r\nlet extensionInitData = null; // Cached data: { id, url, version, backgroundImg, isEnabled, isBackgroundEnabled }\r\nlet isDataReady = false;      // Flag to indicate if extensionInitData is populated\r\n\r\n/**\r\n * Fetches all relevant extension states from chrome.storage.local.\r\n * @returns {Promise<object>} A promise that resolves to an object containing isEnabled and isBackgroundEnabled states.\r\n */\r\nasync function getStatesFromStorage() {\r\n    return new Promise((resolve) => {\r\n        chrome.storage.local.get([EXTENSION_ENABLED_KEY, BACKGROUND_ENABLED_KEY], (result) => {\r\n            if (chrome.runtime.lastError) {\r\n                console.error(\"[Isolated Script] Storage Error getting states:\", chrome.runtime.lastError.message);\r\n                // Default to true for both if storage fails, to ensure features are on by default on error\r\n                resolve({ isEnabled: true, isBackgroundEnabled: true });\r\n                return;\r\n            }\r\n            resolve({\r\n                isEnabled: result[EXTENSION_ENABLED_KEY] !== false,         // Default to true if undefined\r\n                isBackgroundEnabled: result[BACKGROUND_ENABLED_KEY] !== false // Default to true if undefined\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n/**\r\n * Fetches the stored background image (as a data URL).\r\n * @returns {Promise<string|null>} A promise that resolves to the image data URL or null.\r\n */\r\nasync function getStoredBackgroundImage() {\r\n    return new Promise((resolve) => {\r\n        chrome.storage.local.get([IMAGE_STORAGE_KEY], (result) => {\r\n            if (chrome.runtime.lastError) {\r\n                console.error(\"[Isolated Script] Storage Error getting background image:\", chrome.runtime.lastError.message);\r\n                resolve(null);\r\n                return;\r\n            }\r\n            resolve(result[IMAGE_STORAGE_KEY] || null); // Return null if not set\r\n        });\r\n    });\r\n}\r\n\r\n/**\r\n * Prepares the initial data for the extension, including states from storage and manifest details.\r\n * This function populates/updates `extensionInitData`.\r\n * @param {boolean} forceRefresh - If true, re-fetches states and image from storage even if data is already \"ready\".\r\n * @returns {Promise<object|null>} The prepared extension data object, or null on critical error.\r\n */\r\nasync function prepareExtensionData(forceRefresh = false) {\r\n    if (isDataReady && !forceRefresh) {\r\n        return extensionInitData;\r\n    }\r\n\r\n    // console.log(`[Isolated Script] Preparing extension data. Force refresh: ${forceRefresh}`);\r\n    try {\r\n        const states = await getStatesFromStorage(); // Always get the latest states\r\n        const storedImage = await getStoredBackgroundImage(); // Get the latest image\r\n        const manifest = chrome.runtime.getManifest();\r\n\r\n        extensionInitData = {\r\n            id: chrome.runtime.id,\r\n            url: chrome.runtime.getURL(''),\r\n            version: manifest.version,\r\n            backgroundImg: storedImage,           // Current stored image\r\n            isEnabled: states.isEnabled,          // Current main extension enabled state\r\n            isBackgroundEnabled: states.isBackgroundEnabled // Current background enabled state\r\n        };\r\n        isDataReady = true; // Mark data as ready (or re-validated)\r\n        // console.log('[Isolated Script] Extension data prepared successfully:', extensionInitData);\r\n        return extensionInitData;\r\n    } catch (error) {\r\n        console.error('[Isolated Script] Critical error preparing extension data:', error);\r\n        isDataReady = false; // Mark as not ready if there was an error\r\n        extensionInitData = null; // Clear potentially stale data\r\n        return null; // Indicate failure\r\n    }\r\n}\r\n\r\n/**\r\n * Sends the current `extensionInitData` to the MAIN world via postMessage.\r\n * @param {boolean} forceDataRefresh - If true, calls prepareExtensionData with forceRefresh=true before sending.\r\n */\r\nasync function sendInitDataToMainWorld(forceDataRefresh = false) {\r\n    const dataToSend = await prepareExtensionData(forceDataRefresh); // Ensures data is up-to-date if forced\r\n\r\n    if (dataToSend) {\r\n        console.log('[Isolated Script] Sending EXTENSION_INIT to MAIN world. Data:', JSON.stringify(dataToSend));\r\n        window.postMessage({\r\n            type: 'EXTENSION_INIT',\r\n            data: dataToSend\r\n        }, '*'); // Target '*' is okay for same-window communication to MAIN world\r\n    } else {\r\n        console.error('[Isolated Script] Cannot send EXTENSION_INIT to MAIN world because data preparation failed.');\r\n        window.postMessage({\r\n            type: 'EXTENSION_INIT_ERROR',\r\n            error: 'Failed to prepare extension data in isolated world.'\r\n        }, '*');\r\n    }\r\n}\r\n\r\n// --- Event Listeners ---\r\n\r\n// Listen for requests from the MAIN world (e.g., ExtensionCore.init())\r\nwindow.addEventListener('message', async (event) => {\r\n    // Basic security: ensure the message is from the current window and has the expected structure\r\n    if (event.source === window && event.data && event.data.type === 'REQUEST_EXTENSION_INIT') {\r\n        // console.log('[Isolated Script] Received REQUEST_EXTENSION_INIT from MAIN world.');\r\n        // When MAIN world requests data, prepare it (if not ready) and send it.\r\n        // Don't force refresh here; let the initial prepareExtensionData() call handle the first load.\r\n        await sendInitDataToMainWorld();\r\n    }\r\n});\r\n\r\n// Listen for messages from the popup (e.g., toggle changes)\r\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\r\n    console.log('[Isolated Script] Received message from runtime:', request);\r\n\r\n    if (request.type === 'ODEV_EXTENSION_STATE_CHANGED') {\r\n        console.log('[Isolated Script] Main extension state changed by popup. New intended state:', request.enabled);\r\n        // The popup has already updated chrome.storage.local for EXTENSION_ENABLED_KEY.\r\n        // The strategy is to reload the page. On reload, prepareExtensionData will fetch the new state.\r\n        console.log('[Isolated Script] Forcing page reload to apply main extension state change.');\r\n        sendResponse({ status: \"reloading_page_due_to_main_state_change\" }); // Acknowledge before reload\r\n        window.location.reload();\r\n        // Return true because reload is happening, but the function technically \"handles\" the message.\r\n        // The port will close due to reload anyway.\r\n        return true;\r\n    } else if (request.type === 'ODEV_BACKGROUND_STATE_CHANGED') {\r\n        console.log('[Isolated Script] Background enabled state changed by popup. New state:', request.backgroundEnabled);\r\n        // The popup has already updated chrome.storage.local for BACKGROUND_ENABLED_KEY.\r\n        // We need to:\r\n        // 1. Re-prepare extensionInitData to include this new `isBackgroundEnabled` state (and potentially new isEnabled state).\r\n        // 2. Send this updated data to the MAIN world so it can react (e.g., client.js removing/adding background style).\r\n        // NO PAGE RELOAD for this specific change.\r\n\r\n        // Force prepareExtensionData to re-fetch all states from storage to ensure consistency\r\n        sendInitDataToMainWorld(true) // Pass `true` to force data refresh\r\n            .then(() => {\r\n                console.log(\"[Isolated Script] Successfully resent init data to main world after background state change.\");\r\n                sendResponse({ status: \"background_state_updated_and_resent_to_main\" });\r\n            })\r\n            .catch(error => {\r\n                console.error(\"[Isolated Script] Error sending init data to main world after background state change:\", error);\r\n                sendResponse({ status: \"error_updating_main_world_for_background\", error: error.message });\r\n            });\r\n        return true; // IMPORTANT: Indicate that sendResponse will be called asynchronously.\r\n    }\r\n\r\n    // If the message type isn't handled above, and you don't intend to send a response,\r\n    // it's good practice to either return `false` or not return anything explicitly (undefined).\r\n    // This signals to Chrome that the message port can be closed for this listener.\r\n    // console.log(\"[Isolated Script] Unhandled message type:\", request.type);\r\n    // sendResponse({ status: \"unknown_message_type\" }); // Optional: if you want to always respond\r\n    return false; // Or simply don't return if no other branches handle it.\r\n});\r\n\r\n\r\n// --- Initial Execution ---\r\n// Prepare the extension data when the content script is first injected.\r\n// This ensures that `extensionInitData` (including initial states from storage)\r\n// is populated and ready when the MAIN world sends `REQUEST_EXTENSION_INIT`.\r\nprepareExtensionData()\r\n    .then(initialData => {\r\n        if (initialData) {\r\n            // console.log(\"[Isolated Script] Initial data preparation complete on load.\", initialData);\r\n        } else {\r\n            console.error(\"[Isolated Script] Initial data preparation failed on load.\");\r\n        }\r\n    })\r\n    .catch(error => {\r\n        console.error(\"[Isolated Script] Error during initial data preparation on load:\", error);\r\n    });"],"names":[],"sourceRoot":""}